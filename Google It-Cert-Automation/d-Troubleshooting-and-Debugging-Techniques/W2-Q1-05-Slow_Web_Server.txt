[Let's use a tool called ab which stands for Apache Benchmark tool to figure out how slow it is.]
[the average timing of 500 requests, and then pass our site.example.com for the measurement.]
[checking if a website is behaving as expected or not.]
[make a bunch of requests and summarize the results once it's done.]
[options that we could pass like how many requests we want the program to do at the same time, or if the test to finish after timeout, even if not all requests completed, we're making 500 requests so that we can get an average of how long things are taking.]
[We see that the mean time per requests was a 155 milliseconds. While this is not a super huge number, it's definitely more than what we'd expect for such a simple website.]
[Let's connect to the web server and check out what's going on.]
[ssh webserver]
[looking at the output of top]
[bunch of ffmpeg processes running, which are basically using all the available CPU.]
[See those load numbers? Thirty is definitely not normal.]
[Linux shows how much time the processor is busy at a given minute with one meaning it was busy for the whole minute.]
[two processors. So any number above two means that it's overloaded.]
[there were more processes waiting for processor time than the processor had to give.]
[likely culprit for our server being overloaded. ]
[change the processes priorities so that the web server takes precedence.]
[By default, processes start with a priority of zero. But we can change that using the nice and renice commands.]
[nice for starting a process with a different priority and renice for changing the priority of a process that's already running.]
[run renice for all the ffmpeg processes that are running right now.]
[Instead, we can use a quick line of shell script to do this for us.]
[pidof command that receives the process name and returns all the process IDs that have that name.]
[We'll iterate over the output of the pidof command with a for loop and then call renice for each of the process IDs.]
[Renice takes the new priority as the first argument, and the process ID to change as the second one.]
[lowest possible priority which is 19.]
[benchmarking software again]
[153 milliseconds.]
[modify whatever's triggering them to run them one after the other instead of all at the same time.]
[how these processes got started?]
[output of the ps command to get some more information about the processes.]
[We'll call ps ax which shows us all the running processes on the computer, and we'll connect the output of the command to less, to be able to scroll through it.]
[look for the ffmpeg process]
[change into that directory]
[Instead, let's use grep to check if any of these files contains a call to ffmpeg.]
[site: directory, static: directory, views: is a directory]
[command line editor instead.]
[We'll use vim in this case.]
[This might be okay if we only need to convert a couple of videos but launching one separate process for each of the videos in the static directory is overloading our server.]
[only one video conversion process at a time. We'll do that by simply deleting the daemonized part and keeping the part that calls ffmpeg, then save and exit.]
[want to stop these processes but not cancel them completely,]
[go back to home directory]
[iterate through the list of processes using the same for loop with the pit of command that we used earlier.]
[send the cont signal and then wait until the process is done.]
