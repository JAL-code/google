[The scroll buffer is that nifty feature that lets us scroll up and see the things that we executed and their output.]
[take the random numbers generated by the urandom device and show them as both characters and hexadecimal numbers.]
[In a different terminal, let's open top and check out what's going on.]
[Pressing "Shift M" we tell ton that we want to order the programs by how much memory they are using.]
[Let's stop the process, it's filling up the buffer by pressing "Control C".]
[The column labeled RES is the dynamic memory that's preserved for the specific process.]
[The one labeled SHR is for memory that's shared across processes]
[VIRT lists all the virtual memory allocated for each process.]
[fine for a process to have a high value in the VIRT column.]
[The one that usually indicates a problem is the RES column.]
[In this example, we saw what a program that keeps requesting more and more memory looks like.]
[It can usually take a long while until we notice that a program is taking more memory than it should, and it might be hard to tell the difference between memory that's actually needed and memory that's being wasted.]
[This looks like the program is storing more than it should in memory.]
[So we could use the help of a memory profiler here to figure out what the problem is.]
[We'll be using a module called memory profiler.]
[This type of label is called a decorator and it's used in Python to add extra behavior to functions without having to modify the code.]
[In this case, the extra behavior is measuring the use of memory.]
[Once the program finishes, the memory profiler gives us information about which lines are adding or removing data from the memory used by the program.]
